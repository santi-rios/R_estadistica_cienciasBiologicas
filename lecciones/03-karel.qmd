---
title: "Conceptos de Programación con Karel"
author: "Santiago G. Rios"
format: 
    live-html: 
        toc: true
        # theme: simple
        # scrollable: true
        toc-depth: 3
        toc-title: Contenido de la Lección
        # progress: true
        # slide-number: true
        lang: es
        # logo: "https://cran.r-project.org/Rlogo.svg"
webr:
    packages: 
        - karel
        - visNetwork
pyodide:
  packages:
    - matplotlib
    - iPython
    - https://santi-rios.github.io/pykarel_web/pykarel_web-0.3.4-py3-none-any.whl
engine: knitr
navbar: false
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}

## Conceptos básicos de programación

> *Programación*: es el proceso de diseñar y construir un conjunto de instrucciones que le dicen a una computadora cómo realizar una tarea específica.
> Para darle instrucciones a una computadora, necesitamos utilizar un lenguaje de programación.

-   En esta lección, aprenderemos conceptos básicos de programación para desarrollar el pensamiento abstracto y lógico necesario para comunicarnos eficientemente con la computadora.
-   Para comprender estas ideas abstractas de programación, utilizaremos a Karel, un robot que nos ayudará a entender mejor los conceptos de programación.
-   Las dos habilidades que deberás desarrollar son:
    -   **Diseñar algoritmos**: desarrollar o pensar un algoritmo que resuelva un problema.
    -   **Codificación**: escribir el algoritmo en un lenguaje de programación para que la computadora pueda entenderlo y ejecutarlo.


Dominar estos conceptos que veremos es un proceso que tarda tiempo y experiencia con un lenguaje de programación. En este curso, no esperamos que domines estos conceptos de inmediato, pero es necesario que los conozcas ya que son la base de la programación. 

::: {.callout-important title="Modelos Mentales: ¿Cómo aprender a programar?"}

Un modelo mental es una representación *simplificada* de cómo entendemos las partes más importantes de un concepto ([Wilson, 2019](https://teachtogether.tech/en/)). 

Imagina que queremos aprender sobre el átomo y sus componentes. Para comenzar con este tema, podemos utilizar un modelo molecular de bolas y varillas (@fig-atomos) para armar un átomo. Los átomos no son en realidad bolas y las uniones atómicas no son en realidad varillas, pero este modelo permite razonar sobre los componentes químicos (núcleo, enlaces, protones, etc.) y su estructura. Un modelo un poco más sofisticado de un átomo es aquel con una bola pequeña en el centro (el núcleo) rodeada de electrones en la periferia (@fig-atomosmodelos) que nos da más información sobre el átomo (cargas de electrones, protones, etc.). Sin embargo, este último modelo tampoco incorpora todo lo que se sabe del átomo; no obstante, al no incluir la complejidad extra de los modelos atómicos más recientes, estos modelos permiten que creemos un **modelo mental** del átomo.

::: {.columns}

::: {.column width="50%"}

![](../images/atomos_bolas.png){#fig-atomos}

:::

::: {.column width="50%"}

![](../images/atomos_modelo.png){#fig-atomosmodelos}

:::

:::

Ahora imagina que en lugar de usar los ejemplos anteriores para entender el átomo, comenzaras a aprender del tema con el [modelo atómico de Schrödinger](https://es.wikipedia.org/wiki/Ecuaci%C3%B3n_de_Schr%C3%B6dinger), el cual describe a los electrones no como partículas que siguen órbitas definidas alrededor del núcleo, sino como ondas de materia, cuya posición se describe mediante una función de onda (@fig-atomosschori). 

![Orbitales atómicos: regiones del espacio donde es más probable encontrar un electrón.](../images/atomos_schrodi.png){#fig-atomosschori}

A pesar que este modelo incorpora conceptos que se acercan más a la realidad, necesitas crear primero un modelo mental del átomo para aprender, entender y ordenar las ideas complejas de este modelo. Es decir, si primero utilizas los modelos más sencillos que te permiten entender el átomo y cómo se distribuyen los electrones, será más fácil que entiendas el modelo complejo y qué significan los conceptos complejos, como orbitales atómicos.

En el contexto de programación, a veces comenzamos nuestro aprendizaje corriendo comandos y scripts sin entender realmente cómo funciona el código. Esto sería como aprender primero el modelo de Schrödinger (@fig-atomosschori) antes de aprender modelos más sencillos (@fig-atomos). El resultado es que nunca generamos un modelo mental que nos permita aprender eficientemente cómo programar. Por esta razón, usaremos a Karel para comprender los conceptos de programación de manera sencilla, antes de adentrarnos en las funciones y scripts para analizar datos.

:::



```{webr}
#| autorun: true
#| include: false

library(karel)

# Crear un entorno para llevar el conteo de pasos
.karel_env <- new.env(parent = emptyenv())
.karel_env$step_counter <- 1

# Sobrescribir generar_mundo para reiniciar el contador
generar_mundo <- function(mundo) {
  karel::generar_mundo(mundo)
  .karel_env$step_counter <- 1
}

# Funciones auxiliares que generan imágenes estáticas después de cada acción
avanzar <- function() {
  karel::avanzar()
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
}

girar_izquierda <- function() {
  karel::girar_izquierda()
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
}

juntar_coso <- function() {
  karel::juntar_coso()
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
}

poner_coso <- function() {
  karel::poner_coso()
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
}

# Sobrescribir ejecutar_acciones para que genere la imagen final
ejecutar_acciones <- function() {
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
  invisible()
}

# Función girar_derecha optimizada para una sola imagen
girar_derecha <- function() {
  karel::girar_izquierda()
  karel::girar_izquierda()
  karel::girar_izquierda()
  karel:::plot_static_world(.karel_env$step_counter)
  .karel_env$step_counter <<- .karel_env$step_counter + 1
}

```

```{pyodide}
#| autorun: true
#| include: false
from pykarel_web import Karel

```

## Qué es Karel

-   Karel es un robot que vive en un mundo de cuadrículas diseñado para enseñar conceptos básicos de programación.
-   Karel recibe instrucciones en español para moverse por el mundo y realizar tareas específicas.
-   Gracias a que observarás cómo Karel se mueve con cada instrucción que le das, podrás comprender mejor los conceptos de programación, así como los errores que pueden surgir al programar.

Le daremos a Karel instrucciones (en la forma de *funciones*) para que resuelva un problema (*algoritmo*). Cada instrucción del algoritmo modifica el mundo (*entorno*) de alguna manera.

## Cargar el paquete Karel

-   Para que R/Python pueda usar Karel, primero debemos cargar el paquete `karel`. Recuerda la lección anterior donde vimos cómo cargar paquetes/librerías.
-   En la siguiente consola, vamos a ver como cargar las funciones de Karel en R y Python.

::: {.panel-tabset group="language"}

## R

-   En R, para usar las funciones de un paquete, primero debemos cargarlo. Hay dos formas principales de hacerlo:
    1.  **Cargar el paquete completo:** Usando `library(karel)`. Una vez hecho esto, puedes llamar a sus funciones directamente (p. ej., `generar_mundo()`).
    2.  **Llamar funciones específicas:** Usando el operador `::` (p. ej., `karel::generar_mundo()`) sin necesidad de cargar todo el paquete con `library()`.
-   El método `paquete::funcion()` tiene ventajas importantes que usaremos en futuras lecciones, como evitar conflictos entre funciones y hacer el código más claro.
-   Sin embargo, **para esta lección**, usaremos casi exclusivamente funciones del paquete `karel`. Por simplicidad, cargaremos el paquete al inicio con `library(karel)` y luego llamaremos a las funciones directamente.

**Tu tarea:** Carga el paquete `karel` y luego usa la función `generar_mundo()` para crear el mundo 001 pasando el argumento `"mundo001"` a la función `generar_mundo()`.

```{webr}
# Carga el paquete karel
library( ______ )
# Genera el mundo de karel
generar_mundo( ______ )
```

::: {.callout-tip collapse="true" title="Solución" icon="lightbulb"}

```r
library(karel)
generar_mundo("mundo001")
``` 
:::

## Python

-   En Python, recuerda que importamos paquetes con la palabra clave `import`.
-   Adicionalmente, podemos usar la palabra clave `from` para importar funciones específicas de un paquete, de este modo: `from nombre_paquete import funcion`.
-   En el siguiente caso, importaremos la **clase**^[Las clases son *moldes* para crear objetos, mientras que las funciones son bloques de código reutilizables que realizan tareas específicas.] `Karel` del **paquete** `pykarel_web`.
    -   La notación sería `from paquete import clase`.
-   Una vez importada la clase, podemos crear un objeto Karel y usar sus métodos, por ejemplo, `karel.mostrar_animacion()`.
-   Por ahora no te preocupes con estos conceptos nuevos, solo completa el código que falta para importar Karel y crear el mundo de Karel. Si tienes problemas, revisa la clase anterior.
-   **Tu tarea**: Completa la línea que falta para importar Karel del paquete pykarel_web.

```{pyodide}
# Importa la clase Karel del paquete pykarel_web
from ______ import ______

karel = Karel(mundo="laberinto")
karel.mostrar_animacion()
```

::: {.callout-tip collapse="true" title="Solución y Explicación" icon="lightbulb"}

**Solución:**
```python
from pykarel_web import Karel
```

**Explicación:**

En Python, cuando escribes:
```python
from pykarel_web import Karel
```
estás diciendo: "Del *paquete* pykarel_web, importa solo la *clase* Karel".

Esto te permite usar `Karel` directamente en tu código:
```python
karel = Karel(mundo="laberinto")
```

**Alternativa:** Si importaras todo el paquete así:
```python
import pykarel_web
```
tendrías que llamar a la clase como:
```python
karel = pykarel_web.Karel(mundo="laberinto")
```

**¿Por qué usamos `from ... import`?**
- Es más directo y legible
- Evita tener que escribir el nombre completo del paquete cada vez
- Es el patrón recomendado cuando solo necesitas una clase específica

:::

:::



## Mundo de Karel


::: {.panel-tabset group="language"}

## R

-   Observa que el mundo está formado por cuadrículas y Karel se encuentra en una posición específica.
-   Karel siempre mira hacia una de las cuatro direcciones posibles: este, norte, oeste o sur.
-   Los bordes negros representan paredes que Karel no debe cruzar.
-   El cubo morado se llama en el programa un `coso`. Estos `cosos` pueden ser tomados por Karel y guardarlos en su mochila. En el mundo que acabamos de crear, el coso se encuentra en la celda (2, 1)

## Python

-   Observa que el mundo está formado por cuadrículas y Karel se encuentra en una posición específica y una dirección específica.
-   Los bordes negros representan paredes que Karel no puede cruzar.
-   Karel siempre mira hacia una de las cuatro direcciones posibles: este, norte, oeste o sur.
-   La esfera roja se llama en el programa un `coso`. Estos `cosos` pueden ser tomados por Karel y guardarlos en su mochila.

:::

## Funciones de Karel

## Funciones

-   Como vimos previamente, una función es un bloque de código que realiza una tarea específica.
-   Las funciones pueden recibir información (argumentos) y devolver un valor.
    -   **NOTA**: Algunas funciones pueden funcionar sin necesidad de especificar argumentos dentro del paréntesis. Es decir, *no requieren valores explícitos de entrada para funcionar*.
    -   En el caso de karel, solo la función de `generar_mundo` recibe argumentos (para decirle qué mundo generar), las acciones se ejecutan con el paréntesis vacío: `funcion()`


::: {#tbl-funcionesKarel layout-ncol=2}


| Función           | Sintaxis (R)        |
|--------------------|---------------------|
| Avanzar un paso           | `avanzar()`         |
| Girar a la Izquierda |`girar_izquierda()` |
| Juntar 1 Coso        | `juntar_coso()`     |
| Poner 1 Coso         | `poner_coso()`      |
| Ejecutar Acciones y mostrar figuras  | `ejecutar_acciones()` |

: Funciones de Karel en R {#tbl-karelR}

| Función           | Sintaxis (Python)   |
|--------------------|---------------------|
| Avanzar un paso           | `karel.avanzar()`   |
| Girar a la Izquierda | `karel.girar_izquierda()` |
| Juntar 1 Coso        | `karel.juntar_coso()` |
| Poner 1 Coso         | `karel.poner_coso()`  |
| Ejecutar Acciones  y mostrar animación | `karel.mostrar_animacion()` |

: Funciones de Karel en Python {#tbl-karelPy}

:::

::: {.callout-important title="Importante" icon="info"}

- Karel solo avanza si no hay una pared que se lo impida.
- Karel solo sabe girar a la izquierda, NO a la derecha.
- Debe haber al menos un coso en la celda para que Karel pueda realizar la acción `juntar_coso()`.
- Debe haber al menos un coso en la mochila de Karel para que pueda realizar la acción `poner_coso()`.
- La función `ejecutar_acciones()` (R) o `karel.mostrar_animacion()` (Python) le dice a Karel que ejecute las instrucciones. Esto siempre debe ser la última instrucción del programa.
  - En el caso de R, al ejecutar las acciones de crea una imagen por cada instrucción. En el caso de Python, se crea una animación (debes hacer click en Reproducir) de las instrucciones que le das a Karel.

:::

Veamos un primer ejemplo.


::: {.panel-tabset group="language"}

## R

Vamos a pedirle a Karel que:

- genere su mundo
- avance
- junte el coso
- vuelva avanzar
- ejecutar estas acciones

```{webr}

generar_mundo("mundo001")
avanzar()
juntar_coso()
avanzar()
ejecutar_acciones()

```

Qué pasa si intentas avanzar cuando hay una pared enfrente de Karel? Intenta hacerlo y observa el resultado. Agrega la instrucción de avanzar en el siguiente código para observar el error:

```{webr}
generar_mundo("mundo001")
avanzar()
juntar_coso()
avanzar()
______ # agregar instrucción para avanzar
ejecutar_acciones()

```

## Python

Vamos a pedirle a Karel que 

- genere su mundo
- junte el coso
- gire a la izquierda
- vuelva a avanzar
- mostrar animación

```{pyodide}

karel = Karel(mundo="laberinto")
karel.juntar_coso()
karel.girar_izquierda()
karel.avanzar()
karel.mostrar_animacion()

```


Qué pasa si intentas avanzar cuando hay una pared enfrente de Karel? Intenta hacerlo y observa el resultado.

```{pyodide}
from pykarel_web import Karel

karel = Karel(mundo="laberinto")
______ # agregar instrucción para avanzar
karel.mostrar_animacion()
```

:::


## Solución de problemas

::: {.panel-tabset group="language"}

## R

-   Ahora queremos que Karel junte el coso, lo coloque en la Calle 2 y Avenida 5 y finalmente avance a la Calle 2 y Avenida 6, como en la imagen de abajo:

![](https://ropensci.github.io/karel/articles/15.png)

-   Los primeros tres comandos que necesitamos en el programa son los mismos de antes, pero luego Karel tiene que girar a su izquierda para poder bordear la pared y avanzar un lugar, quedando de cara al norte:

![](https://ropensci.github.io/karel/articles/16.png)

-   Ahora necesitamos que Karel gire a la derecha, para que quede mirando al este.
-   Sin embargo, **Karel sólo sabe girar a la izquierda**, no existe ninguna función girar_derecha()
-   Para girar a la derecha, se puede lograr el mismo efecto girando tres veces a la izquierda. Luego, sólo resta que avance 2 veces, coloque el coso y vuelva a avanzar una vez:

> Antes de tratar de escribir el código, es útil realizar mapas conceptuales que nos ayuden a visualizar el problema y los pasos necesarios para resolverlo.

```{mermaid}
flowchart TD
    A["generar mundo"] -- avanzar --> B("juntar coso")
    B -- avanzar --> n1["girar izquierda"]
    n2["girar izquierda"] --> n3["girar izquierda"]
    n1 -- avanzar --> n2
    n8["poner_coso"] -- avanzar --> n4["ejecutar acciones"]
    n9["girar izquierda"] -- avanzar</br>avanzar --> n8
    n3 --> n9
```

- Ahora, solo escribe el código. Recuerda las funciones de karel (@tbl-karelR)

```{webr}
#| min-lines: 2

generar_mundo("mundo001")


```



::: {.callout collapse="true" title="Solución"}

```r

generar_mundo("mundo001")
avanzar()
juntar_coso()
avanzar()
girar_izquierda()
avanzar()
girar_izquierda()
girar_izquierda()
girar_izquierda()
avanzar()
avanzar()
poner_coso()
avanzar()
ejecutar_acciones()

```

:::

## Python

-   Ahora queremos que Karel junte el coso, gire a la izquierda, avance 2 pasos, gire a la derecha y avance hasta el siguiente coso. Corre la siguiente animación para ver lo que queremos que haga karel.

```{pyodide}
#| caption: Immediate Execution
#| autorun: true
#| echo: false


from pykarel_web import Karel

karel = Karel(mundo="laberinto")
karel.juntar_coso()
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
karel.girar_izquierda()
karel.girar_izquierda()
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
karel.mostrar_animacion()
```

-   Sin embargo, **Karel sólo sabe girar a la izquierda**, no existe ninguna función girar_derecha()
-   Para girar a la derecha, se puede lograr el mismo efecto girando tres veces a la izquierda. Luego, sólo resta que avance:

> Antes de tratar de escribir el código, es útil realizar mapas conceptuales que nos ayuden a visualizar el problema y los pasos necesarios para resolverlo.

![](../images/kare_py_1.png)

:::


Como ves, el código se está volviendo un poco más largo y confuso cuando aumentamos el número de instrucciones. A medida que aprendas más sobre programación, escribirás código más eficiente, corto y legible. 

### Descomponer un problema en pasos

![](https://www.origoeducation.com/wp-content/uploads/2019/10/Decomposing-Situations-1.jpg)

-   Para solucionar el problema (**algorítmo**) pasado, es más sencillo dividir el problema en partes más pequeñas (**subalgoritmos**), lo que se conoce como **descomposición algorítmica o modular**.
    -   Un subalgoritmo se escribe una vez y es reutilizado por cualquier algoritmo que lo necesite.
    -   Adicionalmente, si un problema implica tareas que se repiten varias veces, esas tareas pueden definirse como un subalgoritmo separado, escrito una vez pero usado en múltiples lugares.
-   En programación, existen varios términos para diferentes tipos de subalgoritmos, como *subrutinas*, *funciones*, *procedimientos*, *métodos* y *subprogramas*.
-   En este tutorial, nos referiremos a los subalgoritmos como funciones.
    -   Muchas de las funciones que usamos en R son funciones predefinidas, como `print()`, `mean()`, `sum()`, etc.
    -   Sin embargo, también podemos crear nuestras propias funciones para resolver problemas específicos.

## Función Girar Derecha

-   En la sección anterior Karel necesitaba doblar a la derecha y lo logramos indicándole que gire tres veces a la izquierda.
-   Vamos a crear una función que nos permita girar a la derecha para no tener que escribir `girar_izquierda` 3 veces cada vez que queramos girar a la izquierda.


::: {.panel-tabset group="language"}
## R

-   En R, las funciones se crean con la palabra clave `function`. Observa el siguiente código que indica la estructura básica de una función en R:

``` r
nombre_funcion_nueva <- function() {
    # Código de la función
}
```

-   Ahora, para crear la función `girar_derecha()`, necesitamos que Karel gire tres veces a la izquierda.
-   Crea la función:


```{webr}
girar_derecha <- function() {
  ______
  ______
  ______
}
```

-   Observa que usamos el operador de asignación `<-` para asociar a ese nombre la definición de una función, similar a como lo hacemos con las variables.
-   Ahora, vamos a usar la función `girar_derecha()` en el programa de Karel para que pueda girar a la derecha.

```{webr}
generar_mundo("mundo001")
avanzar()
juntar_coso()
avanzar()
girar_izquierda()
avanzar()
______ # usa la función girar_derecha
avanzar()
avanzar()
poner_coso()
avanzar()
ejecutar_acciones()
```


::: {.callout collapse="true" title="Solución"}

```r
girar_derecha <- function() {
  girar_izquierda()
  girar_izquierda()
  girar_izquierda()
}

generar_mundo("mundo001")
avanzar()
juntar_coso()
avanzar()
girar_izquierda()
avanzar()
girar_derecha() # usa la función girar_derecha
avanzar()
avanzar()
poner_coso()
avanzar()
ejecutar_acciones()

```

:::


## Python

-   En Python, las funciones se crean con la palabra clave `def`. Observa el siguiente código que indica la estructura básica de una función en Python:

``` Python
def nombre_funcion_nueva():
    # Código de la función
```

-   Ahora, para crear la función `gira_derecha()`, necesitamos que Karel gire tres veces a la izquierda.

-   Vamos a crearla:

```{pyodide}

def gira_derecha():
    ______
    ______
    ______
```

-   Ahora, vamos a usar la función `gira_derecha()` en el programa de Karel para que pueda girar a la derecha.
    -   NOTA: Como nosotros creamos la función `gira_derecha()`, no tienes que llamar a esta función con el prefijo `karel.`.

```{pyodide}
karel = Karel(mundo="laberinto")
karel.juntar_coso()
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
______ # usa la función gira_derecha()
karel.avanzar()
karel.avanzar()
karel.mostrar_animacion()
```



::: {.callout collapse="true" title="Solución"}

```python
def gira_derecha():
    karel.girar_izquierda()
    karel.girar_izquierda()
    karel.girar_izquierda()

karel = Karel(mundo="laberinto")
karel.juntar_coso()
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
gira_derecha() # usa la función gira_derecha()
karel.avanzar()
karel.avanzar()
karel.mostrar_animacion()

```

:::


:::

## Ejercicio - Función Dar Vuelta

-   Crea una función que le permita dar una vuelta de 180º a Karel (mirar hacia la dirección contraria).
-   Corre el código de Karel y verifica que Karel puede girar 180º. Si la función está bien escrita, Karel debería regresar a su posición original.
-   Llama la función `dar_vuelta()`.
-   Si tienes problemas, puedes ver la solución.

:::: {.panel-tabset group="language"}

## R

-   Ahora, vamos a crear la función `dar_vuelta()` en el programa de Karel para que pueda girar 180 grados y lláma la función donde se te pide.
    -   Si todo sale bien, Karel debería regresar a su posición original.
-   Si tienes problemas, puedes ver la solución a continuación.

::: {.callout collapse="true"}
``` {webr}
#| exercise: karel_dar_vuelta_r

# Crea la función dar_vuelta()
______ 

generar_mundo("mundo001")
avanzar()
avanzar()
______ # llamar a la función dar vuelta
avanzar()
avanzar()
ejecutar_acciones()
```

:::

::: {.solution exercise="karel_dar_vuelta_r"}

## Solución:

``` r
#| code-fold: true
#| code-summary: "Mostrar Respuesta"
dar_vuelta <- function() {
  girar_izquierda()
  girar_izquierda()
}

generar_mundo("mundo001")
avanzar()
avanzar()
dar_vuelta() # llamar a la función dar vuelta
avanzar()
avanzar()
ejecutar_acciones()
```

:::

## Python

-   Ahora, vamos a crear la función `dar_vuelta()` en el programa de Karel para que pueda girar 180 grados y lláma la función donde se te pide.
    -   Si todo sale bien, Karel debería regresar a su posición original.
-   Para este ejercicio, debes importar de nuevo a `Karel` a partir de `pykarel_web`
-   Si tienes problemas, puedes ver la solución a continuación.

::: {.callout collapse="true"}
``` {pyodide}
#| exercise: karel_dar_vuelta_py
# importa Karel de pykarel_web
______

# Define la función dar_vuelta
______


karel = Karel(mundo="laberinto")
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
______ # llamar a la función dar vuelta
karel.avanzar()
karel.avanzar()
karel.mostrar_animacion()
```

:::

::: {.solution exercise="karel_dar_vuelta_py"}

## Solución:

``` Python
from pykarel_web import Karel

def dar_vuelta():
    karel.girar_izquierda()
    karel.girar_izquierda()

karel = Karel(mundo="laberinto")
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
dar_vuelta() # llamar a la función dar vuelta
karel.avanzar()
karel.avanzar()
karel.mostrar_animacion()
```

:::

::::



## Ejercicio - Recolectar todos los cosos

-   Antes de continuar con los siguientes temas, intenta resolver el siguiente ejercicio con lo que has aprendido hasta ahora.
-   Puedes resolverlos en R o Python, como prefieras. Recuerda la sintaxis de cada lenguaje presentada en @tbl-funcionesKarel.
    -   Puedes utilizar las funciones de la @tbl-funcionesKarel, o crear tus propias funciones para resolver los problemas. 
-   Si tienes problemas en solucionarlos, corre el código de Karel con pocos pasos y observa lo que está haciendo bien y lo que está haciendo mal.
    -   El objetivo de estos ejercicios NO es que encuentres la solución a la primera... el objetico es que juegues y te familiarizes con karel y eventualmente encuentres tu solución... sin importar si es la más óptima.

:::: {.panel-tabset group="language"}

## R

-   genera el mundo `mundo010` y resuelve el siguiente problema:
-   Karel debe tomar los 4 `cosos` de la posición `fila=1, columna=2` y dejarlos en posiciones distintas.

```{webr}
#| caption: Immediate Execution
#| autorun: true
#| echo: false


library(karel)
generar_mundo("mundo010")
```

-   No hay una respuesta correcta, la idea es que explores con Karel.

```{webr}

```


```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Posible Respuesta"
library(karel)
generar_mundo("mundo010")
avanzar()
juntar_coso()
juntar_coso()
juntar_coso()
juntar_coso()
avanzar()
poner_coso()
avanzar()
poner_coso()
avanzar()
poner_coso()
girar_izquierda()
avanzar()
poner_coso()
ejecutar_acciones()
```


## Python

-   genera el mundo `cosos` y resuelve el siguiente problema:
-   Karel debe tomar 2 `cosos` y dejarlos en posiciones distintas.
    -   NOTA: algunos cosos de este mundo (como el que se encuentra en la posición `fila=4, columna=4`) tienen un número que significa que en esa posicción existe más de un coso, representado por el número. Esto significa que puedes tomar más de un coso en esta posición, o puedes optar por tomar cada coso de distintas posiciones. 


```{pyodide}
#| caption: Immediate Execution
#| autorun: true
#| echo: false


from pykarel_web import Karel
karel = Karel(mundo="cosos")
karel.ejecutar_acciones()
```

-   No hay una respuesta correcta, la idea es que explores con Karel.

```{pyodide}

```


```{py}
#| eval: false
#| code-fold: true
#| code-summary: "Posible Respuesta"
from pykarel_web import Karel

karel = Karel(mundo="cosos")
karel.juntar_coso()
karel.avanzar()
karel.avanzar()
karel.girar_izquierda()
karel.avanzar()
karel.avanzar()
karel.juntar_coso()
karel.avanzar()
karel.poner_coso()
karel.avanzar()
karel.poner_coso()
karel.mostrar_animacion()
```


::::
